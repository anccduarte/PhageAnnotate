# -*- coding: utf-8 -*-

import sys
sys.path.append("..")
from Bio import SeqIO
from collect_sequences import CollectSequences
from ml_dataset import MLDataset
from ml_model import MLModel
from pathlib import Path

# ---

def collect() -> None:
    """
    Collects all sequences present in the genome records of bacteriophages.
    The resulting .fasta file is then filtered to remove duplicates.
    """
    # inititialize directory for storing the .fasta file
    Path("naive/sequences").mkdir(exist_ok=True)
    # collect sequences
    CollectSequences(db="naive/sequences/all",
                     cname="all",
                     terms=["not a protein common name"],
                     negatives=True).get_sequences(taxid="2711619")

# ---

def _retrieve_protein_names(nfile: str) -> list:
    """
    Given the path to a .fasta file containing DNA sequences, it retrieves
    the names of the proteins associated to all sequences and stores them
    in a list object.

    Parameters
    ----------
    nfile: str
        The name of the .fasta file containing the DNA sequences
    """
    # initialize list object for storing protein names
    protein_names = []
    # loop through the records in <nfile> and add descriptions
    records = SeqIO.parse(nfile, "fasta")
    for rec in records:
        name = "|".join(rec.description.split("|")[2:])
        protein_names.append(name)
    # return list of protein names
    return protein_names
    
def build_db() -> None:
    """
    Builds a database consisting of a dataset of featurized sequences (the
    ones present in the file generated by "collect").
    """
    # specify name of the file
    nfile = "naive/sequences/all/txid2731619_all.fasta"
    # retrieve the protein names associated to the sequences in <nfile>
    protein_names = _retrieve_protein_names(nfile)
    # initialize <ttable> and <icodons>
    ttable = "11"
    icodons = ("TTG","CTG","ATT","ATC","ATA","ATG","GTG")
    # featurize sequences present in <nfile>
    dframe = MLDataset(file=nfile,
                       prot_name="unknown",
                       ttable=ttable
                       icodons=icodons).build_dataset()
    # substitute last column of <dframe> (all "unknown") by <descriptions>
    del dframe["Function"]
    dframe["Function"] = protein_names
    # initialize directory for storing the dataset
    Path("naive/database").mkdir(exist_ok=True)
    # save dataframe to a .csv file
    dframe.to_csv("naive/database/all_sequences.csv")
    
# ---
    
def build_model() -> None:
    """
    Builds a gradient boosting model (HGBC) fed on the dataset generated by
    "build_db". It tests the model on 20% of the data and displays the
    results: accuracy score, precision score, recall score and f1-score.
    """
    # initialize directory for storing .joblib files
    Path("naive/models").mkdir(exist_ok=True)
    # build model and display results (metrics on testing data)
    MLModel(data_path="naive/database/all_sequences.csv",
            models_dir="naive/models",
            algorithm="gradient-boosting",
            test_size=0.2,
            final_model=True)


if __name__ == "__main__":
    
    import utils
    
    args = utils.get_args(("-action",))
    action = args.action
    
    if action is None:
        raise Exception("<action> has no default value. Please do:\n"
                        ">>> python _build_naive.py -action <action>")
        
    options = {"collect": collect,
               "build-db": build_db,
               "build-model": build_model}
    
    if action not in options:
        raise ValueError(f"{action!r} is not valid for 'action'. "
                         f"Choose one of {{{', '.join(options)}}}")
        
    func = options[action]
    func()
